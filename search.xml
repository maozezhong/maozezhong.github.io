<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MTCNN论文笔记]]></title>
    <url>%2F2018%2F04%2F11%2FMTCNN%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[脸部检测及landmarks标记 背景 论文: Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks 代码地址: Github 作者博客 概况 论文提出了一种深层的级联multi-task框架 分三个阶段的深度卷积网络由粗到细的检测人脸及预测landmark location 论文提出了一种有效的online hard sample mining的策略来提升性能.(在每个mini-batch中选择前向计算误差前70%大的样本用来BP) 方法1.总体框架 2.三步骤 pre：先将图片resize，叠成“金字塔” stage1：采用P-Net获得候选窗口以及bounding box回归向量，然后用估计的bounding box回归向量去校准候选窗口。然后使用非极大值抑制(NMS,non-maximum supression)来合并高度重合的候选窗口。（非极大值抑制：首先对每个窗口按照score（置信度）进行递降排序，取score最大的窗口，然后计算剩下的与最大的窗口之间的IOU，也就是重叠面积，如果大于一定阈值就将框删除，然后一直重复上述步骤直到候选窗口为空） stage2：将所有的候选数据喂给R-Net进一步消除不合适的候选窗口，并且通过bounding box回归及NMS去校准 stage3：与2类似，不同的是这一阶段的目的是输出脸部细节，即五个脸部的landmarks位置 3.CNN结构 将5x5大小的滤波窗口减小到3x3大小的滤波窗口以减少计算 增加深度以更好的提取特征 4.训练 face classification损失函数(2分类，交叉熵损失) bounding box regression损失(计算预测坐标向量和真实坐标向量的欧氏距离) facial landmark localization损失(欧式距离) multi-source，alpha为任务重要性，beta为样本类型索引取值为0或1，样本种类包括{negative(IoU&lt;0.3), positive(IoU&gt;0.65), part face(0.4&lt;IoU&lt;0.65), landmark face}；在计算训练的总体损失的时候，classifier, bounding box regression和landmarks detection的权重是不一样的；训练数据共分为4类，比例为 online hard sample mining,在每个mini-batch中选择前向计算误差前70%大的样本用来BP) 实验结果 online hard sample mining效果 联合检测及校准的效果 检验脸部检测的效果 检验脸部校准的效果]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>mtcnn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找及其变种]]></title>
    <url>%2F2018%2F04%2F10%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D%2F</url>
    <content type="text"><![CDATA[二分模板int binarySearch(vector&lt;int&gt;nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left+(right-left)/2; if(key ? nums[mid]){ right = mid-1; }else{ left = mid+1; } } //可能还得加判断left，right是否在范围内 return left or right; } 标准二分查找//1.标准二分 int binarySearch_1(vector&lt;int&gt; nums, int key) { int left = 0, right=nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else if(key&gt;nums[mid]){ left = mid+1; }else{ return mid; } } return -1; } 二分查找变种1.最后一个小于key的元素//2.最后一个小于key的元素 int binarySearch_2(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(right&gt;=0) return right; else return -1; } 2.第一个大于key的元素//3.第一个大于key的值 int binarySearch_3(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(left&lt;nums.size()) return left; else return -1; } 3.最后一个小于等于key的元素//4.最后一个小于等于key的值 int binarySearch_4(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } return right; } 4.第一个大于等于key的元素//5.第一个大于等于key的元素 int binarySearch_5(vector&lt;int&gt; nums, int key) { int left = 0,right=nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } return left; } 5.第一个与key相等的元素//6.第一个与key相等的元素 int binarySearch_6(vector&lt;int&gt;nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(left&lt;nums.size() &amp;&amp; nums[left]==key) return left; return -1; } 6.最后一个与key相等的元素//7.最后一个与key相等的元素 int binarySearch_7(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(right&gt;=0 &amp;&amp; nums[right]==key) return right; return -1; } 完整测试代码#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; //1.标准二分 int binarySearch_1(vector&lt;int&gt; nums, int key) { int left = 0, right=nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else if(key&gt;nums[mid]){ left = mid+1; }else{ return mid; } } return -1; } //2.最后一个小于key的元素 int binarySearch_2(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(right&gt;=0) return right; else return -1; } //3.第一个大于key的值 int binarySearch_3(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(left&lt;nums.size()) return left; else return -1; } //4.最后一个小于等于key的值 int binarySearch_4(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } return right; } //5.第一个大于等于key的元素 int binarySearch_5(vector&lt;int&gt; nums, int key) { int left = 0,right=nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } return left; } //6.第一个与key相等的元素 int binarySearch_6(vector&lt;int&gt;nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(left&lt;nums.size() &amp;&amp; nums[left]==key) return left; return -1; } //7.最后一个与key相等的元素 int binarySearch_7(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(right&gt;=0 &amp;&amp; nums[right]==key) return right; return -1; } void test() { //int test_arr[] = {1,2,2,2,3,4,5};//test1 //int test_arr[] = {2,2,2,4,3};//test2 //int test_arr[] = {1,2,2,2};//test3 //int test_arr[] = {1,2,2,2};//test4 //int test_arr[] = {1,2,3,4};//test5 //int test_arr[] = {1,2,3,5};//test6 int test_arr[] = {1,2,2,5};//test7 vector&lt;int&gt; test_vec(test_arr, test_arr+sizeof(test_arr)/sizeof(int)); cout&lt;&lt;binarySearch_7(test_vec,3)&lt;&lt;endl; } int main() { test(); return 0; }]]></content>
      <categories>
        <category>基础/经典算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FaceNet论文笔记]]></title>
    <url>%2F2018%2F04%2F10%2FFaceNet%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[背景 论文: FaceNet: A Unified Embedding for Face Recognition and Clustering 代码地址: Github 概况 论文提出了名为FaceNet的框架，该框架学习的是从脸图到欧式距离的映射，这样就可以同图片之间的距离来衡量相似度。相比之前直接用softmax更加高效。 端到端，框架的输出是一个多维度的embedding向量。 损失函数采用的是三联子损失(triplet loss) 文章采用的deepCNN的结构为：1）Zeiler&amp;Fergus加上额外的1x1xN的卷积层,2）inception model 该算法在LFW数据集上实现了99.63%的精确度，在YouTube脸库数据集上实现了95.12%的精确度，准确度比以往算法提升了30% 方法 模型结构 triplet损失函数(三联子) triplet选择 计算argmax和argmin 方案一：每n步产生triplets，使用数据的子集计算argmax, argmin;方案二(论文中采取的方案)：在线生成triplets, 在mini-batch中计算argmax和argmin，论文中一个mini-batch每个人选了40张脸图，并且额外增加了随机的负样本脸图 选择hardest的负样本在实际中会导致训练时候在早起就陷入局部最优，所以论文中采用semi-hard的策略 评估标准 true accept false accept validation rate &amp;&amp; false accept rate 实验结果 不同模型对比 不同图片质量对比 不同embedding维度对比 不同训练集数量对比]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>FaceNet</tag>
      </tags>
  </entry>
</search>
