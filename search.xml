<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二分查找及其变种]]></title>
    <url>%2F2018%2F04%2F10%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D%2F</url>
    <content type="text"><![CDATA[二分模板int binarySearch(vector&lt;int&gt;nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left+(right-left)/2; if(key ? nums[mid]){ right = mid-1; }else{ left = mid+1; } } //可能还得加判断left，right是否在范围内 return left or right; } 标准二分查找//1.标准二分 int binarySearch_1(vector&lt;int&gt; nums, int key) { int left = 0, right=nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else if(key&gt;nums[mid]){ left = mid+1; }else{ return mid; } } return -1; } 二分查找变种1.最后一个小于key的元素//2.最后一个小于key的元素 int binarySearch_2(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(right&gt;=0) return right; else return -1; } 2.第一个大于key的元素//3.第一个大于key的值 int binarySearch_3(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(left&lt;nums.size()) return left; else return -1; } 3.最后一个小于等于key的元素//4.最后一个小于等于key的值 int binarySearch_4(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } return right; } 4.第一个大于等于key的元素//5.第一个大于等于key的元素 int binarySearch_5(vector&lt;int&gt; nums, int key) { int left = 0,right=nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } return left; } 5.第一个与key相等的元素//6.第一个与key相等的元素 int binarySearch_6(vector&lt;int&gt;nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(left&lt;nums.size() &amp;&amp; nums[left]==key) return left; return -1; } 6.最后一个与key相等的元素//7.最后一个与key相等的元素 int binarySearch_7(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(right&gt;=0 &amp;&amp; nums[right]==key) return right; return -1; } 完整测试代码#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; //1.标准二分 int binarySearch_1(vector&lt;int&gt; nums, int key) { int left = 0, right=nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else if(key&gt;nums[mid]){ left = mid+1; }else{ return mid; } } return -1; } //2.最后一个小于key的元素 int binarySearch_2(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(right&gt;=0) return right; else return -1; } //3.第一个大于key的值 int binarySearch_3(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(left&lt;nums.size()) return left; else return -1; } //4.最后一个小于等于key的值 int binarySearch_4(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } return right; } //5.第一个大于等于key的元素 int binarySearch_5(vector&lt;int&gt; nums, int key) { int left = 0,right=nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } return left; } //6.第一个与key相等的元素 int binarySearch_6(vector&lt;int&gt;nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;=nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(left&lt;nums.size() &amp;&amp; nums[left]==key) return left; return -1; } //7.最后一个与key相等的元素 int binarySearch_7(vector&lt;int&gt; nums, int key) { int left = 0, right = nums.size()-1; while(left&lt;=right) { int mid = left + (right-left)/2; if(key&lt;nums[mid]){ right = mid-1; }else{ left = mid+1; } } if(right&gt;=0 &amp;&amp; nums[right]==key) return right; return -1; } void test() { //int test_arr[] = {1,2,2,2,3,4,5};//test1 //int test_arr[] = {2,2,2,4,3};//test2 //int test_arr[] = {1,2,2,2};//test3 //int test_arr[] = {1,2,2,2};//test4 //int test_arr[] = {1,2,3,4};//test5 //int test_arr[] = {1,2,3,5};//test6 int test_arr[] = {1,2,2,5};//test7 vector&lt;int&gt; test_vec(test_arr, test_arr+sizeof(test_arr)/sizeof(int)); cout&lt;&lt;binarySearch_7(test_vec,3)&lt;&lt;endl; } int main() { test(); return 0; }]]></content>
      <categories>
        <category>基础/经典算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FaceNet论文笔记]]></title>
    <url>%2F2018%2F04%2F10%2FFaceNet%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[背景 论文: FaceNet: A Unified Embedding for Face Recognition and Clustering 代码地址: Github 概况 论文提出了名为FaceNet的框架，该框架学习的是从脸图到欧式距离的映射，这样就可以同图片之间的距离来衡量相似度。相比之前直接用softmax更加高效。 端到端，框架的输出是一个多维度的embedding向量。 损失函数采用的是三联子损失(triplet loss) 文章采用的deepCNN的结构为：1）Zeiler&amp;Fergus加上额外的1x1xN的卷积层,2）inception model 该算法在LFW数据集上实现了99.63%的精确度，在YouTube脸库数据集上实现了95.12%的精确度，准确度比以往算法提升了30% 方法 模型结构 triplet损失函数(三联子) triplet选择 计算argmax和argmin 方案一：每n步产生triplets，使用数据的子集计算argmax, argmin;方案二(论文中采取的方案)：在线生成triplets, 在mini-batch中计算argmax和argmin，论文中一个mini-batch每个人选了40张脸图，并且额外增加了随机的负样本脸图 选择hardest的负样本在实际中会导致训练时候在早起就陷入局部最优，所以论文中采用semi-hard的策略 评估标准 true accept false accept validation rate &amp;&amp; false accept rate 实验结果 不同模型对比 不同图片质量对比 不同embedding维度对比 不同训练集数量对比]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>FaceNet</tag>
      </tags>
  </entry>
</search>
